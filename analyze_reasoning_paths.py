#!/usr/bin/env python3
"""
Analyze Reasoning Paths

Analyzes reasoning paths generated by generate_reasoning_paths.py.
Creates detailed reports, statistics, and insights.
"""

import json
from typing import List, Dict
from pathlib import Path
from collections import defaultdict, Counter


def analyze_flexibility(paths_data: List[Dict]) -> Dict:
    """Analyze reasoning flexibility patterns."""
    flexibility_stats = {
        'examples_with_multiple_paths': 0,
        'avg_paths_per_example': 0,
        'max_paths': 0,
        'path_distribution': defaultdict(int),
        'method_usage': defaultdict(int)
    }
    
    total_paths = 0
    valid_examples = []
    
    for example in paths_data:
        if 'error' in example:
            continue
            
        valid_examples.append(example)
        path_count = example.get('total_paths', 0)
        total_paths += path_count
        
        if path_count > 1:
            flexibility_stats['examples_with_multiple_paths'] += 1
        
        if path_count > flexibility_stats['max_paths']:
            flexibility_stats['max_paths'] = path_count
            
        # Path count distribution
        if path_count == 1:
            flexibility_stats['path_distribution']['single_path'] += 1
        elif path_count <= 10:
            flexibility_stats['path_distribution']['2-10_paths'] += 1
        elif path_count <= 100:
            flexibility_stats['path_distribution']['11-100_paths'] += 1
        else:
            flexibility_stats['path_distribution']['100+_paths'] += 1
            
        # Method usage
        method = example.get('method', 'unknown')
        flexibility_stats['method_usage'][method] += 1
    
    if valid_examples:
        flexibility_stats['avg_paths_per_example'] = total_paths / len(valid_examples)
    
    return flexibility_stats


def find_position_patterns(paths_data: List[Dict]) -> Dict:
    """Find which reasoning steps are flexible vs fixed in position."""
    patterns = {
        'always_first_steps': Counter(),
        'always_last_steps': Counter(),
        'flexible_steps': Counter(),
        'step_position_variance': {}
    }
    
    for example in paths_data:
        if 'error' in example or not example.get('paths'):
            continue
        
        paths = example['paths']
        if len(paths) <= 1:
            continue
            
        # Analyze position variance for each step
        step_positions = defaultdict(list)
        
        for path in paths:
            sequence = path.get('sequence', [])
            for pos, step in enumerate(sequence):
                step_positions[step].append(pos)
        
        # Categorize steps
        for step, positions in step_positions.items():
            unique_positions = set(positions)
            
            if len(unique_positions) == 1:
                # Fixed position step
                if positions[0] == 0:
                    patterns['always_first_steps'][step] += 1
                elif positions[0] == len(paths[0]['sequence']) - 1:
                    patterns['always_last_steps'][step] += 1
            else:
                # Flexible position step
                patterns['flexible_steps'][step] += 1
                
            # Calculate position variance
            if len(positions) > 1:
                variance = max(positions) - min(positions)
                patterns['step_position_variance'][step] = variance
    
    return patterns


def generate_report(paths_data: List[Dict], output_dir: Path):
    """Generate comprehensive analysis report."""
    # Basic statistics
    total_examples = len(paths_data)
    successful = len([ex for ex in paths_data if 'error' not in ex])
    failed = total_examples - successful
    
    # Analyze flexibility
    flex_stats = analyze_flexibility(paths_data)
    
    # Analyze position patterns
    position_patterns = find_position_patterns(paths_data)
    
    # Create report
    report_file = output_dir / "analysis_report.txt"
    with open(report_file, 'w') as f:
        f.write("REASONING PATHS ANALYSIS REPORT\n")
        f.write("=" * 50 + "\n\n")
        
        # Summary
        f.write("SUMMARY\n")
        f.write("-" * 20 + "\n")
        f.write(f"Total Examples: {total_examples}\n")
        f.write(f"Successful: {successful}\n")
        f.write(f"Failed: {failed}\n")
        f.write(f"Examples with Multiple Paths: {flex_stats['examples_with_multiple_paths']}\n")
        f.write(f"Average Paths per Example: {flex_stats['avg_paths_per_example']:.1f}\n")
        f.write(f"Maximum Paths Found: {flex_stats['max_paths']}\n\n")
        
        # Method usage
        f.write("GENERATION METHODS\n")
        f.write("-" * 20 + "\n")
        for method, count in flex_stats['method_usage'].items():
            f.write(f"{method.title()}: {count} examples\n")
        f.write("\n")
        
        # Path distribution
        f.write("PATH COUNT DISTRIBUTION\n")
        f.write("-" * 25 + "\n")
        for category, count in flex_stats['path_distribution'].items():
            f.write(f"{category.replace('_', ' ').title()}: {count} examples\n")
        f.write("\n")
        
        # Position patterns
        f.write("REASONING STEP PATTERNS\n")
        f.write("-" * 25 + "\n")
        
        if position_patterns['always_first_steps']:
            f.write("Steps that always come first:\n")
            for step, count in position_patterns['always_first_steps'].most_common(5):
                f.write(f"  {step}: {count} examples\n")
            f.write("\n")
        
        if position_patterns['always_last_steps']:
            f.write("Steps that always come last:\n")
            for step, count in position_patterns['always_last_steps'].most_common(5):
                f.write(f"  {step}: {count} examples\n")
            f.write("\n")
        
        if position_patterns['flexible_steps']:
            f.write("Most flexible steps (variable position):\n")
            for step, count in position_patterns['flexible_steps'].most_common(10):
                variance = position_patterns['step_position_variance'].get(step, 0)
                f.write(f"  {step}: {count} examples (variance: {variance})\n")
    
    print(f"üìÑ Analysis report: {report_file}")


def create_summary_json(paths_data: List[Dict], output_dir: Path):
    """Create JSON summary for programmatic use."""
    flex_stats = analyze_flexibility(paths_data)
    position_patterns = find_position_patterns(paths_data)
    
    summary = {
        'total_examples': len(paths_data),
        'successful_examples': len([ex for ex in paths_data if 'error' not in ex]),
        'flexibility_stats': dict(flex_stats),
        'position_patterns': {
            'always_first_steps': dict(position_patterns['always_first_steps']),
            'always_last_steps': dict(position_patterns['always_last_steps']),
            'flexible_steps': dict(position_patterns['flexible_steps'])
        }
    }
    
    # Convert defaultdict to regular dict
    summary['flexibility_stats']['path_distribution'] = dict(summary['flexibility_stats']['path_distribution'])
    summary['flexibility_stats']['method_usage'] = dict(summary['flexibility_stats']['method_usage'])
    
    summary_file = output_dir / "analysis_summary.json"
    with open(summary_file, 'w') as f:
        json.dump(summary, f, indent=2)
    
    print(f"üìä Summary JSON: {summary_file}")


def analyze_paths_file(paths_file: str, output_dir: str = None):
    """Analyze reasoning paths file and generate reports."""
    # Set output directory
    if output_dir is None:
        paths_path = Path(paths_file)
        output_dir = paths_path.parent / f"{paths_path.stem}_analysis"
    else:
        output_dir = Path(output_dir)
    
    output_dir.mkdir(exist_ok=True)
    
    # Load paths data
    with open(paths_file, 'r') as f:
        paths_data = json.load(f)
    
    # Generate analysis
    generate_report(paths_data, output_dir)
    create_summary_json(paths_data, output_dir)
    
    # Quick stats
    successful = len([ex for ex in paths_data if 'error' not in ex])
    total_paths = sum(ex.get('total_paths', 0) for ex in paths_data)
    
    print(f"‚úÖ Analysis complete!")
    print(f"üìÅ Results in: {output_dir}")
    print(f"üéØ {successful}/{len(paths_data)} examples, {total_paths} total paths")


def main():
    """CLI interface."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Analyze reasoning paths JSON file")
    parser.add_argument("paths_file", help="Reasoning paths JSON file")
    parser.add_argument("--output", help="Output directory for analysis")
    
    args = parser.parse_args()
    
    analyze_paths_file(args.paths_file, args.output)


if __name__ == "__main__":
    main() 